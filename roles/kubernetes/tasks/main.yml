---
# Kubernetes Role - Main Tasks
# Handles both master and worker node setup with comprehensive error handling

- name: Wait for apt locks to be released
  shell: |
    while fuser /var/lib/dpkg/lock-frontend >/dev/null 2>&1 || \
          fuser /var/lib/dpkg/lock >/dev/null 2>&1 || \
          fuser /var/lib/apt/lists/lock >/dev/null 2>&1 || \
          fuser /var/cache/apt/archives/lock >/dev/null 2>&1; do
      echo "Waiting for apt locks..."
      sleep 5
    done
  changed_when: false

- name: Fix interrupted dpkg installations
  shell: |
    dpkg --configure -a
    apt-get install -f -y
  ignore_errors: yes
  changed_when: false

- name: Disable swap immediately
  shell: swapoff -a
  when: ansible_swaptotal_mb > 0
  changed_when: false

- name: Disable swap permanently in fstab
  replace:
    path: /etc/fstab
    regexp: '^([^#].*?\sswap\s+.*)$'
    replace: '# \1'
  when: ansible_swaptotal_mb > 0

- name: Load required kernel modules
  modprobe:
    name: "{{ item }}"
    state: present
  loop:
    - overlay
    - br_netfilter

- name: Persist kernel modules on boot
  copy:
    dest: /etc/modules-load.d/k8s.conf
    content: |
      overlay
      br_netfilter

- name: Configure sysctl for Kubernetes networking
  sysctl:
    name: "{{ item.key }}"
    value: "{{ item.value }}"
    state: present
    reload: yes
    sysctl_file: /etc/sysctl.d/k8s.conf
  loop:
    - { key: 'net.bridge.bridge-nf-call-iptables', value: '1' }
    - { key: 'net.bridge.bridge-nf-call-ip6tables', value: '1' }
    - { key: 'net.ipv4.ip_forward', value: '1' }

- name: Create apt keyrings directory
  file:
    path: /etc/apt/keyrings
    state: directory
    mode: '0755'

- name: Add Kubernetes apt signing key
  shell: |
    curl -fsSL https://pkgs.k8s.io/core:/stable:/v{{ k8s_version }}/deb/Release.key | \
    gpg --dearmor -o /etc/apt/keyrings/kubernetes-apt-keyring.gpg --yes
  args:
    creates: /etc/apt/keyrings/kubernetes-apt-keyring.gpg

- name: Add Kubernetes apt repository
  copy:
    dest: /etc/apt/sources.list.d/kubernetes.list
    content: |
      deb [signed-by=/etc/apt/keyrings/kubernetes-apt-keyring.gpg] https://pkgs.k8s.io/core:/stable:/v{{ k8s_version }}/deb/ /

- name: Update apt cache
  apt:
    update_cache: yes
  retries: 3
  delay: 10
  register: apt_update_result
  until: apt_update_result is succeeded

- name: Install Docker and container runtime dependencies
  apt:
    name:
      - apt-transport-https
      - ca-certificates
      - curl
      - gnupg
      - lsb-release
      - docker.io
      - containerd
    state: present
    update_cache: no
  retries: 3
  delay: 10

- name: Install Kubernetes packages
  apt:
    name:
      - kubelet={{ k8s_version }}.*
      - kubeadm={{ k8s_version }}.*
      - kubectl={{ k8s_version }}.*
    state: present
  retries: 3
  delay: 10

- name: Hold Kubernetes packages at current version
  dpkg_selections:
    name: "{{ item }}"
    selection: hold
  loop:
    - kubelet
    - kubeadm
    - kubectl

- name: Create Docker daemon configuration directory
  file:
    path: /etc/docker
    state: directory
    mode: '0755'

- name: Configure Docker daemon (systemd cgroup driver)
  copy:
    dest: /etc/docker/daemon.json
    content: |
      {
        "exec-opts": ["native.cgroupdriver=systemd"],
        "log-driver": "json-file",
        "log-opts": {
          "max-size": "100m",
          "max-file": "3"
        },
        "storage-driver": "overlay2"
      }
  notify: restart docker

- name: Ensure Docker service is enabled and started
  systemd:
    name: docker
    state: started
    enabled: yes
    daemon_reload: yes

- name: Download cri-dockerd package
  get_url:
    url: https://github.com/Mirantis/cri-dockerd/releases/download/v0.3.10/cri-dockerd_0.3.10.3-0.ubuntu-jammy_amd64.deb
    dest: /tmp/cri-dockerd.deb
    mode: '0644'
  retries: 3
  delay: 10

- name: Install cri-dockerd
  apt:
    deb: /tmp/cri-dockerd.deb
    state: present

- name: Ensure cri-docker service is enabled and started
  systemd:
    name: "{{ item }}"
    state: started
    enabled: yes
    daemon_reload: yes
  loop:
    - cri-docker.service
    - cri-docker.socket

- name: Add ubuntu user to docker group
  user:
    name: ubuntu
    groups: docker
    append: yes

# ===== MASTER NODE SPECIFIC TASKS =====
- name: Check if Kubernetes is already initialized
  stat:
    path: /etc/kubernetes/admin.conf
  register: kubeadm_init_check
  when: node_role == 'master'

- name: Initialize Kubernetes master
  command: >
    kubeadm init
    --pod-network-cidr={{ pod_network_cidr }}
    --token={{ token }}
    --token-ttl=0
    --cri-socket=unix:///var/run/cri-dockerd.sock
    --ignore-preflight-errors=NumCPU,Mem
  when: 
    - node_role == 'master'
    - not kubeadm_init_check.stat.exists
  register: kubeadm_init_output

- name: Display kubeadm init output
  debug:
    var: kubeadm_init_output.stdout_lines
  when: 
    - node_role == 'master'
    - kubeadm_init_output is defined

- name: Create .kube directory for ubuntu user
  file:
    path: /home/ubuntu/.kube
    state: directory
    owner: ubuntu
    group: ubuntu
    mode: '0755'
  when: node_role == 'master'

- name: Copy Kubernetes admin config to ubuntu user
  copy:
    src: /etc/kubernetes/admin.conf
    dest: /home/ubuntu/.kube/config
    remote_src: yes
    owner: ubuntu
    group: ubuntu
    mode: '0600'
  when: node_role == 'master'

- name: Create .kube directory for root user
  file:
    path: /root/.kube
    state: directory
    mode: '0755'
  when: node_role == 'master'

- name: Copy Kubernetes admin config to root user
  copy:
    src: /etc/kubernetes/admin.conf
    dest: /root/.kube/config
    remote_src: yes
    mode: '0600'
  when: node_role == 'master'

- name: Set KUBECONFIG environment variable for ubuntu
  lineinfile:
    path: /home/ubuntu/.bashrc
    line: 'export KUBECONFIG=/home/ubuntu/.kube/config'
    create: yes
  when: node_role == 'master'

- name: Wait for kube-apiserver to be ready
  wait_for:
    host: localhost
    port: 6443
    delay: 10
    timeout: 300
  when: node_role == 'master'

- name: Install Calico Tigera Operator
  become: yes
  become_user: ubuntu
  shell: |
    kubectl apply -f https://raw.githubusercontent.com/projectcalico/calico/{{ calico_version }}/manifests/tigera-operator.yaml --server-side
  environment:
    KUBECONFIG: /home/ubuntu/.kube/config
  when: node_role == 'master'
  retries: 5
  delay: 10
  register: calico_operator
  until: calico_operator.rc == 0

- name: Wait for Tigera Operator to be ready
  become: yes
  become_user: ubuntu
  shell: |
    kubectl wait --for=condition=Available --timeout=300s deployment/tigera-operator -n tigera-operator
  environment:
    KUBECONFIG: /home/ubuntu/.kube/config
  when: node_role == 'master'
  retries: 3
  delay: 20
  ignore_errors: yes

- name: Create Calico custom resources manifest
  copy:
    dest: /tmp/calico-custom-resources.yaml
    content: |
      apiVersion: operator.tigera.io/v1
      kind: Installation
      metadata:
        name: default
      spec:
        calicoNetwork:
          ipPools:
          - blockSize: 26
            cidr: {{ pod_network_cidr }}
            encapsulation: VXLANCrossSubnet
            natOutgoing: Enabled
            nodeSelector: all()
      ---
      apiVersion: operator.tigera.io/v1
      kind: APIServer
      metadata:
        name: default
      spec: {}
  when: node_role == 'master'

- name: Apply Calico custom resources
  become: yes
  become_user: ubuntu
  shell: |
    kubectl apply -f /tmp/calico-custom-resources.yaml
  environment:
    KUBECONFIG: /home/ubuntu/.kube/config
  when: node_role == 'master'
  retries: 5
  delay: 15
  register: calico_resources
  until: calico_resources.rc == 0

- name: Wait for Calico pods to be ready
  become: yes
  become_user: ubuntu
  shell: |
    kubectl wait --for=condition=Ready pods --all -n calico-system --timeout=600s
  environment:
    KUBECONFIG: /home/ubuntu/.kube/config
  when: node_role == 'master'
  retries: 3
  delay: 30
  ignore_errors: yes

- name: Remove master node taints (allow scheduling on master)
  become: yes
  become_user: ubuntu
  shell: |
    kubectl taint nodes --all node-role.kubernetes.io/control-plane- || true
    kubectl taint nodes --all node-role.kubernetes.io/master- || true
  environment:
    KUBECONFIG: /home/ubuntu/.kube/config
  when: node_role == 'master'
  changed_when: false

# ===== WORKER NODE SPECIFIC TASKS =====
- name: Check if node is already joined to cluster
  stat:
    path: /etc/kubernetes/kubelet.conf
  register: kubelet_conf_check
  when: node_role == 'worker'

- name: Join worker node to Kubernetes cluster
  command: >
    kubeadm join {{ master_ip }}:6443
    --token={{ token }}
    --discovery-token-unsafe-skip-ca-verification
    --cri-socket=unix:///var/run/cri-dockerd.sock
  when:
    - node_role == 'worker'
    - not kubelet_conf_check.stat.exists
  register: kubeadm_join_output
  retries: 5
  delay: 30

- name: Display kubeadm join output
  debug:
    var: kubeadm_join_output.stdout_lines
  when:
    - node_role == 'worker'
    - kubeadm_join_output is defined

# ===== COMMON POST-INSTALLATION TASKS =====
- name: Ensure kubelet is enabled and started
  systemd:
    name: kubelet
    state: started
    enabled: yes
    daemon_reload: yes

- name: Display cluster join command (master only)
  become: yes
  become_user: ubuntu
  shell: |
    kubeadm token create --print-join-command
  environment:
    KUBECONFIG: /home/ubuntu/.kube/config
  when: node_role == 'master'
  register: join_command
  changed_when: false

- name: Show join command for workers
  debug:
    msg: "{{ join_command.stdout }}"
  when:
    - node_role == 'master'
    - join_command is defined
