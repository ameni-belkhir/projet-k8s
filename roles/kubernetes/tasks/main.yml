---
# ==================== R√âCUP√âRER LES VARIABLES D'ENVIRONNEMENT ====================
- name: R√©cup√©rer les variables d'environnement
  set_fact:
    node_role: "{{ lookup('env', 'NODE_ROLE') | default(node_role | default('')) }}"
    master_ip: "{{ lookup('env', 'MASTER_IP') | default(master_ip | default('')) }}"
    token: "{{ lookup('env', 'TOKEN') | default('abcdef.1234567890abcdef') }}"
    # Variables pour la version des composants (rend la mise √† jour plus facile)
    k8s_version: "v1.29"
    cri_dockerd_version: "0.3.11"

- name: Afficher la configuration
  debug:
    msg: "Configuration - R√¥le: {{ node_role }}, Master IP: {{ master_ip }}"

# ==================== VALIDATION ====================
- name: Valider le format du token (pour le master)
  assert:
    that:
      - token is match('[a-z0-9]{6}\.[a-z0-9]{16}')
    fail_msg: "Le token doit √™tre au format 'xxxxxx.xxxxxxxxxxxxxxxx' (6 caract√®res, point, 16 caract√®res)."
  when: node_role == "master"
  ignore_errors: yes  # Si le token est invalide, on continue mais on pr√©vient

# ==================== T√ÇCHES COMMUNES (Master & Worker) ====================
- name: "üîß T√ÇCHES COMMUNES - Ex√©cution sur {{ node_role }}"
  block:
    # 1. Protection contre les verrous APT & R√©parations
    - name: Attendre que le verrou APT soit lib√©r√©
      shell: while fuser /var/lib/dpkg/lock-frontend >/dev/null 2>&1; do sleep 5; done;
      changed_when: false

    - name: R√©parer les installations de paquets interrompues
      shell: |
        dpkg --configure -a
        apt-get install -f -y
      ignore_errors: yes
      changed_when: false

    # 2. Pr√©paration du Syst√®me (Swap, Modules, R√©seau)
    - name: Supprimer les anciens d√©p√¥ts Kubernetes
      file:
        path: "{{ item }}"
        state: absent
      loop:
        - /etc/apt/sources.list.d/kubernetes.list
        - /etc/apt/keyrings/kubernetes-apt-keyring.asc

    - name: D√©sactiver le Swap
      shell: |
        swapoff -a
        sed -i '/\sswap\s/ s/^\(.*\)$/#\1/g' /etc/fstab
      when: ansible_swaptotal_mb > 0
      changed_when: false

    - name: Charger les modules noyau
      modprobe:
        name: "{{ item }}"
        state: present
      loop: [overlay, br_netfilter]

    - name: Configurer le sysctl pour le r√©seau
      sysctl:
        name: "{{ item.key }}"
        value: "{{ item.value }}"
        state: present
        reload: yes
      loop:
        - { key: 'net.bridge.bridge-nf-call-iptables', value: '1' }
        - { key: 'net.ipv4.ip_forward', value: '1' }

    # 3. Installation des D√©pendances & CRI-Dockerd
    - name: Cr√©er le r√©pertoire keyrings
      file:
        path: /etc/apt/keyrings
        state: directory
        mode: '0755'

    - name: Ajouter la cl√© GPG et le d√©p√¥t Kubernetes (v{{ k8s_version }})
      block:
        - name: T√©l√©charger la cl√© GPG
          get_url:
            url: "https://pkgs.k8s.io/core:/stable:/{{ k8s_version }}/deb/Release.key"
            dest: /tmp/kubernetes-apt-keyring.key
            mode: '0644'
        - name: D√©placer la cl√© d√©compress√©e
          shell: |
            gpg --dearmor -o /etc/apt/keyrings/kubernetes-apt-keyring.gpg < /tmp/kubernetes-apt-keyring.key
          args:
            creates: /etc/apt/keyrings/kubernetes-apt-keyring.gpg
        - name: Ajouter le d√©p√¥t
          copy:
            dest: /etc/apt/sources.list.d/kubernetes.list
            content: |
              deb [signed-by=/etc/apt/keyrings/kubernetes-apt-keyring.gpg] https://pkgs.k8s.io/core:/stable:/{{ k8s_version }}/deb/ /
          register: repo_added

    - name: Mettre √† jour le cache APT si le d√©p√¥t a chang√©
      apt:
        update_cache: yes
      when: repo_added.changed

    - name: Installer Docker et les outils K8s
      apt:
        name:
          - docker.io
          - kubelet
          - kubeadm
          - kubectl
        state: present
        update_cache: no  # d√©j√† fait si n√©cessaire

    - name: Configurer Docker (Cgroup systemd)
      copy:
        dest: /etc/docker/daemon.json
        content: |
          {
            "exec-opts": ["native.cgroupdriver=systemd"],
            "log-driver": "json-file",
            "storage-driver": "overlay2"
          }
      notify: Red√©marrer docker

    # ----------------------------------------------------------------------
    # Installation robuste de cri-dockerd (g√®re diff√©rentes releases Ubuntu)
    # ----------------------------------------------------------------------
    - name: Installer et d√©marrer cri-dockerd
      block:
        # V√©rifier si cri-dockerd est d√©j√† install√©
        - name: V√©rifier si cri-dockerd est d√©j√† pr√©sent
          command: dpkg-query -W -f='${Status}' cri-dockerd
          register: cri_dockerd_check
          failed_when: false
          changed_when: false

        - name: D√©finir un flag pour l'installation
          set_fact:
            cri_dockerd_installed: "{{ cri_dockerd_check.rc == 0 and 'installed' in cri_dockerd_check.stdout }}"

        # Si non install√©, d√©terminer la release Ubuntu
        - name: Obtenir la release Ubuntu (ex: focal, jammy, noble)
          set_fact:
            ubuntu_codename: "{{ ansible_distribution_release }}"
          when: not cri_dockerd_installed

        - name: Mapper le nom de la release pour l'URL (releases support√©es par les paquets cri-dockerd)
          set_fact:
            supported_releases:
              focal: "focal"      # 20.04
              jammy: "jammy"      # 22.04
              noble: "noble"      # 24.04
            release_for_url: "{{ supported_releases[ubuntu_codename] | default('') }}"
          when: not cri_dockerd_installed

        # Tenter l'installation via .deb si la release est support√©e
        - name: Installer cri-dockerd via .deb (release support√©e)
          when:
            - not cri_dockerd_installed
            - release_for_url != ""
          block:
            - name: Supprimer tout ancien fichier corrompu
              file:
                path: /tmp/cri-dockerd.deb
                state: absent

            - name: T√©l√©charger cri-dockerd .deb pour {{ ubuntu_codename }}
              get_url:
                url: "https://github.com/Mirantis/cri-dockerd/releases/download/v{{ cri_dockerd_version }}/cri-dockerd_{{ cri_dockerd_version }}.3-0.ubuntu-{{ release_for_url }}_amd64.deb"
                dest: /tmp/cri-dockerd.deb
                mode: '0644'
                timeout: 60
              register: download_result
              until: download_result is success
              retries: 3
              delay: 5

            - name: Installer le paquet .deb
              apt:
                deb: /tmp/cri-dockerd.deb
                state: present

        # Fallback : installation via binaire pr√©compil√© (si .deb non disponible)
        - name: Installer cri-dockerd via binaire (fallback)
          when:
            - not cri_dockerd_installed
            - release_for_url == ""
          block:
            - name: T√©l√©charger l'archive binaire
              get_url:
                url: "https://github.com/Mirantis/cri-dockerd/releases/download/v{{ cri_dockerd_version }}/cri-dockerd-{{ cri_dockerd_version }}.amd64.tgz"
                dest: /tmp/cri-dockerd.tgz
                mode: '0644'
              register: bin_download

            - name: Extraire et installer le binaire
              shell: |
                tar -xzf /tmp/cri-dockerd.tgz -C /tmp/
                install -o root -g root -m 0755 /tmp/cri-dockerd/cri-dockerd /usr/local/bin/cri-dockerd
              args:
                creates: /usr/local/bin/cri-dockerd

            - name: Cr√©er le fichier service systemd pour cri-dockerd
              copy:
                dest: /etc/systemd/system/cri-docker.service
                content: |
                  [Unit]
                  Description=CRI Interface for Docker Application Container Engine
                  Documentation=https://docs.mirantis.com
                  After=docker.service
                  Wants=docker.service

                  [Service]
                  Type=notify
                  ExecStart=/usr/local/bin/cri-dockerd --container-runtime-endpoint fd://
                  Restart=always
                  RestartSec=10s

                  [Install]
                  WantedBy=multi-user.target
              when: bin_download is changed

            - name: Activer et d√©marrer cri-dockerd
              systemd:
                name: cri-docker
                state: started
                enabled: yes
                daemon_reload: yes

        # Red√©marrer les services si n√©cessaire (commun aux deux m√©thodes)
        - name: Red√©marrer les services (si installation/modification)
          systemd:
            name: "{{ item }}"
            state: restarted
            enabled: yes
            daemon_reload: yes
          loop:
            - docker
            - cri-docker
          when: not cri_dockerd_installed  # Ne red√©marrer que si on vient d'installer

  when: node_role in ["master", "worker"]

# ==================== T√ÇCHES SP√âCIFIQUES AU MASTER ====================
- name: "üëë T√ÇCHES MASTER - Initialisation du cluster"
  when: node_role == "master"
  block:
    - name: V√©rifier que le cluster n'est pas d√©j√† initialis√©
      stat:
        path: /etc/kubernetes/admin.conf
      register: k8s_initialized

    - name: Initialiser le Master Kubernetes (avec v√©rifications cibl√©es)
      command: >
        kubeadm init --pod-network-cidr=192.168.0.0/16
        --token={{ token }}
        --cri-socket unix:///var/run/cri-dockerd.sock
        --ignore-preflight-errors=Swap,FileContent--proc-sys-net-bridge-bridge-nf-call-iptables,FileContent--proc-sys-net-ipv4-ip_forward
      args:
        creates: /etc/kubernetes/admin.conf
      when: not k8s_initialized.stat.exists
      register: kubeadm_init
      # Si la commande √©choue, afficher la sortie
      failed_when: kubeadm_init.rc != 0 and "FileExists" not in kubeadm_init.stderr

    - name: Configurer Kubeconfig pour l'utilisateur ubuntu
      block:
        - name: Cr√©er le dossier .kube
          file:
            path: /home/ubuntu/.kube
            state: directory
            owner: ubuntu
            group: ubuntu
            mode: '0755'

        - name: Copier admin.conf
          copy:
            src: /etc/kubernetes/admin.conf
            dest: /home/ubuntu/.kube/config
            remote_src: yes
            owner: ubuntu
            group: ubuntu
            mode: '0600'
      when: kubeadm_init is changed or not k8s_initialized.stat.exists

# ==================== T√ÇCHES SP√âCIFIQUES AU WORKER ====================
- name: "üîß T√ÇCHES WORKER - Join au cluster"
  when: node_role == "worker"
  block:
    - name: V√©rifier que l'IP du master est fournie
      fail:
        msg: "La variable d'environnement MASTER_IP doit √™tre d√©finie pour les workers"
      when: master_ip == ""

    - name: Attendre que le master soit pr√™t (port 6443)
      wait_for:
        host: "{{ master_ip }}"
        port: 6443
        delay: 10
        timeout: 300
        state: started

    - name: V√©rifier si le worker a d√©j√† rejoint
      stat:
        path: /etc/kubernetes/kubelet.conf
      register: kubelet_conf

    - name: Joindre le Worker au Cluster
      command: >
        kubeadm join {{ master_ip }}:6443
        --token={{ token }}
        --discovery-token-unsafe-skip-ca-verification
        --cri-socket unix:///var/run/cri-dockerd.sock
      args:
        creates: /etc/kubernetes/kubelet.conf
      when: not kubelet_conf.stat.exists

# ==================== HANDLERS ====================
handlers:
  - name: Red√©marrer docker
    systemd:
      name: docker
      state: restarted
      daemon_reload: yes
